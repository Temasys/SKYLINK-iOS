
- (void)peerConnection:(RTCPeerConnection *)peerConnection didStartReceivingOnTransceiver:(RTCRtpTransceiver *)transceiver
{
self.peerConnectionU = peerConnection;
NSString *p_tid = @"";
p_tid = [self holderForPeerConnection:peerConnection].tid;
if (self.isMCURoom) {
for (NSString *transceiverId in self.transceiverIdPeerIdMap.allKeys) {
if ([transceiverId isEqualToString:transceiver.mid]) {
p_tid = self.transceiverIdPeerIdMap[transceiverId];
}
}
}
SKDLog(@" Temasys didStartReceivingOnTransceiver p_tid ---> %@", p_tid);
dispatch_async(dispatch_get_main_queue(), ^{
RTC_SKYLINK_EAGLVideoView *remoteVideoView;
RTCVideoTrack *remoteVideoTrack = nil;
RTCAudioTrack *remoteAudioTrack = nil;
BOOL shouldSentMessage = NO;
if (transceiver.mediaType == RTCRtpMediaTypeVideo) {
remoteVideoTrack = (RTCVideoTrack *)(transceiver.receiver.track);
}
if (transceiver.mediaType == RTCRtpMediaTypeAudio) {
remoteAudioTrack = (RTCAudioTrack *)(transceiver.receiver.track);
}
if (remoteVideoTrack && self->haveVideoSend) {
SKPRVLog(@"RTCPeerConnectionDelegate: PCO(%@) onAddStream - Got video stream.", p_tid);
if (!self.remoteVideoViewPool) self.remoteVideoViewPool = [NSMutableDictionary dictionary];
remoteVideoView = [self.remoteVideoViewPool objectForKey:p_tid];

if (!remoteVideoView) {
remoteVideoView = [[RTC_SKYLINK_EAGLVideoView alloc] initWithFrame:[UIScreen mainScreen].bounds];
[self.remoteVideoViewPool setObject:remoteVideoView forKey:p_tid];
shouldSentMessage = YES;
}
remoteVideoView.delegate = self;
[remoteVideoView renderFrame:nil];
[remoteVideoTrack addRenderer:remoteVideoView];
if (remoteVideoTrack) remoteVideoView.videoTrack = remoteVideoTrack;
if (remoteAudioTrack) remoteVideoView.audioTrack = remoteAudioTrack;

SKDLog(@"remoteVideoView.videoTrack ---> %@, remoteVideoView.audioTrack ---> %@", remoteVideoView.videoTrack, remoteVideoView.audioTrack);

if (self.isMCURoom) {
if (self.remotePeerDelegate && [self.remotePeerDelegate respondsToSelector:@selector(connection:didRenderPeerVideo:peerId:)] && shouldSentMessage) {
dispatch_async(dispatch_get_main_queue(), ^{
[self helperDO_didRenderPeerVideo:remoteVideoView wantsToTriggerForPeer:p_tid];
});
}
} else {
if (self.remotePeerDelegate && [self.remotePeerDelegate respondsToSelector:@selector(connection:didRenderPeerVideo:peerId:)]  && ![p_tid isMCU] && shouldSentMessage) {
dispatch_async(dispatch_get_main_queue(), ^{
[self helperDO_didRenderPeerVideo:remoteVideoView wantsToTriggerForPeer:p_tid];
});
}
}
}
});
}









dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[self userDidFinishSetup:viewController callback:callback];
});






- (void)startLocalMedia:(void (^)(void))callbackBlock { // needs to happen in the main thread
if (connectionCount++ == 0) {
SKPRVLog(@"(info) Initialize RTCPeerConnectionFactory ...");
RTCInitializeSSL(); //[RTCPeerConnectionFactory initializeSSL];
}

SKPRVLog(@"(info) Create pcConstrainsts ...");
self.pcConstraints = [[RTCMediaConstraints alloc] initWithMandatoryConstraints:@{@"OfferToReceiveAudio" : [SKYLINKUtilities constraintValueForBool:haveAudioReceive], @"OfferToReceiveVideo" : [SKYLINKUtilities constraintValueForBool:haveVideoReceive], @"googAutoGainControl": [NSString stringWithFormat:@"%@", [NSNumber numberWithBool:myConfig.audioAutoGainControl]], @"googNoiseSuppression": [NSString stringWithFormat:@"%@", [NSNumber numberWithBool:myConfig.audioNoiseSuppression]], @"googHighpassFilter": [NSString stringWithFormat:@"%@", [NSNumber numberWithBool:myConfig.audioHighPassFilter]], @"googEchoCancellation": [NSString stringWithFormat:@"%@", [NSNumber numberWithBool:myConfig.audioEchoCancellation]]} optionalConstraints:@{@"internalSctpDataChannels" : kRTCMediaConstraintsValueTrue, @"DtlsSrtpKeyAgreement" : kRTCMediaConstraintsValueTrue, @"googDscp" : kRTCMediaConstraintsValueTrue}];
if (!singleMediaStream) {
SKPRVLog(@"(info) Create localMediaStream ...");
/*RTCMediaStream*/ lms = [self.peerConnectionFactory mediaStreamWithStreamId:[self myStreamId]];
self.localMediaStream = lms;
singleMediaStream = lms;
// The iOS simulator doesn't provide any sort of camera capture support or emulation (http://goo.gl/rHAnC1) so don't bother trying to open a local stream.
RTCVideoTrack* localVideoTrack;

// TODO(tkchin): local video capture for OSX. See
// https://code.google.com/p/webrtc/issues/detail?id=3417.
#if !TARGET_IPHONE_SIMULATOR && TARGET_OS_IPHONE

if (haveVideoSend) {
[SKYLINKUtilities checkPermissionVideo];
SKPRVLog(@"[info] Create videoSource ...");

RTCVideoSource *localVideoSource = [self.peerConnectionFactory videoSource];
self.foundationVideoSource = localVideoSource;
RTCCameraVideoCapturer *capturer = [[RTCCameraVideoCapturer alloc] initWithDelegate:localVideoSource];
_capturer = capturer;
if (myConfig.preferedSessionPresets) {
for (NSString *preset in myConfig.preferedSessionPresets) {
if ([((RTCCameraVideoCapturer *)localVideoSource).captureSession canSetSessionPreset:preset]) {
[((RTCCameraVideoCapturer *)localVideoSource).captureSession setSessionPreset:preset];
break;
}
}
}

SKPRVLog(@"(info) Create localVideoTrack ...");
localVideoTrack = [self.peerConnectionFactory videoTrackWithSource:localVideoSource trackId:[NSString stringWithFormat:@"%@v0", [self myStreamId]]];
_localVTrack = localVideoTrack;
if (localVideoTrack) [lms addVideoTrack:localVideoTrack];

SKPRVLog(@"(info) Create localVideoView ...");
self.localVideoView = [[RTC_SKYLINK_EAGLVideoView alloc] initWithFrame:[UIScreen mainScreen].bounds];
self.localVideoView.delegate = self;
[self.localVideoView renderFrame:nil];
[localVideoTrack addRenderer:self.localVideoView];
self.localVideoView.videoTrack = localVideoTrack;
[self.localVideoTracks addObject:localVideoTrack];
SKYLINKMedia *localCameraVideoMedia = [[SKYLINKMedia alloc] initWithMediaTrack:localVideoTrack isVideo:YES createMediaID:YES];
localCameraVideoMedia.mediaType = SKYLINKMediaTypeVideoCamera;
localCameraVideoMedia.mediaState = SKYLINKMediaStateActive;
localCameraVideoMedia.previousMediaState = SKYLINKMediaStateUnavailable;
localCameraVideoMedia.videoView = self.localVideoView;
[self.localPeer.localSkylinkMediaMap setObject:localCameraVideoMedia forKey:localCameraVideoMedia.mediaID];
_localCameraMediaId = localCameraVideoMedia.mediaID;

if (self.lifeCycleDelegate && [self.lifeCycleDelegate respondsToSelector:@selector(connection:didRenderUserVideo:)]) {
dispatch_async(dispatch_get_main_queue(), ^{

// Flip if front camera
if (self->haveVideoSend && [self.localVideoView.videoTrack isEnabled]) { // will be true, but the check does not hurt
BOOL _usingFrontCamera = YES;
AVCaptureDevicePosition position =  _usingFrontCamera ? AVCaptureDevicePositionFront : AVCaptureDevicePositionBack;
AVCaptureDevice *device = [[SKYLINKUtilities sharedUtils] findDeviceForPosition:position];
AVCaptureDeviceFormat *format = [[SKYLINKUtilities sharedUtils] selectFormatForDevice:device capturer:self->_capturer];

if (format == nil) {
RTCLogError(@"No valid formats for device %@", device);
NSAssert(NO, @"");
return;
}

NSInteger fps = [[SKYLINKUtilities sharedUtils] selectFpsForFormat:format];
[capturer startCaptureWithDevice:device format:format fps:fps];
self.cameraDevice = device;
}
[self.lifeCycleDelegate connection:self didRenderUserVideo:self.localVideoView];
});
}
}
#else
SKWLog(@"Local video capturing is not supported on Simulator");
#endif
if (haveAudioSend) {
[SKYLINKUtilities checkPermissionAudio];
SKPRVLog(@"(info) Create localAudioTrack ...");
RTCAudioSource *audioSource = [self.peerConnectionFactory audioSourceWithConstraints:self.pcConstraints];
RTCAudioTrack *audioTrack = [self.peerConnectionFactory audioTrackWithSource:audioSource trackId:[NSString stringWithFormat:@"%@a0", [self myStreamId]]];
[lms addAudioTrack:audioTrack];
self.localAudioTrack = audioTrack;
[self.localAudioTracks addObject:audioTrack];
SKYLINKMedia *localAudioMedia = [[SKYLINKMedia alloc] initWithMediaTrack:audioTrack isVideo:NO createMediaID:YES];
localAudioMedia.mediaType = SKYLINKMediaTypeAudio;
localAudioMedia.mediaState = SKYLINKMediaStateActive;
localAudioMedia.previousMediaState = SKYLINKMediaStateUnavailable;
[self.localPeer.localSkylinkMediaMap setObject:localAudioMedia forKey:localAudioMedia.mediaID];
_localAudioMediaId = localAudioMedia.mediaID;
self.localAudioMedia = localAudioMedia;
}
SKPRVLog(@"(info) onICEServers - added local stream.");
if (callbackBlock) callbackBlock();
}
}





for (RTCRtpSender *sender in self.peerConnectionU.senders) {
[self.peerConnectionU removeTrack:sender];

}
[self.peerConnectionU addTrack:self.localAudioTrack streamIds:@[[NSString stringWithFormat:@"%@_sharing", [self myStreamId]]]];







if (self->_localScreenMediaId && self->_localScreenMediaId.length > 0) {
SKYLINKMedia *localScreenMedia = self.localPeer.localSkylinkMediaMap[_localScreenMediaId];
localScreenMedia.rtpSender = v1sender;
[self.localPeer.localSkylinkMediaMap setObject:localScreenMedia forKey:localScreenMedia.mediaID];
}

if (![self.senderDict.allKeys containsObject:@"v1"]) {
RTCRtpSender *v1sender = [self.peerConnectionU addTrack:localVideoTrack streamIds:@[[self myStreamId]]];
[self.localVideoTracks addObject:localVideoTrack];
[self.senderDict setObject:v1sender forKey:@"v1"];

[self.localVideoView renderFrame:nil];
[localVideoTrack addRenderer:self.localVideoView];
self.localVideoView.videoTrack = localVideoTrack;
self.localVideoView.audioTrack = self.localAudioTrack;

for (NSString *remotePeerId in self.remotePeerIdPool) {
[self sendOfferForUnifiedPlanOf:remotePeerId];
}

}
else {
[self.localVideoView renderFrame:nil];
[localVideoTrack addRenderer:self.localVideoView];
self.localVideoView.videoTrack = localVideoTrack;
self.localVideoView.audioTrack = self.localAudioTrack;



}





else {
RTCRtpSender *v1sender = self.senderDict[@"v1"];
RTCRtpSender *v0sender = self.senderDict[@"v0"];
for (RTCRtpSender *sender in self.peerConnectionU.senders) {
if ([sender isEqual:v1sender]) [self.peerConnectionU removeTrack:sender];
if ([sender isEqual:v0sender]) [self.peerConnectionU removeTrack:sender];
}
[self.senderDict removeObjectForKey:@"v1"];
[self.senderDict removeObjectForKey:@"v0"];
//        [self.peerConnectionU addTrack:self.localAudioTrack streamIds:@[[self myStreamId]]];
RTCRtpSender *new_v0sender = [self.peerConnectionU addTrack:_localVTrack streamIds:@[[self myStreamId]]];
if (new_v0sender) [self.senderDict setObject:new_v0sender forKey:@"v0"];

//        [self.localVideoView renderFrame:nil];
[_localVTrack addRenderer:self.localVideoView];
self.localVideoView.videoTrack = _localVTrack;
self.localVideoView.audioTrack = self.localAudioTrack;

for (NSString *remotePeerId in self.remotePeerIdPool) {
[self sendOfferForUnifiedPlanOf:remotePeerId];
}
}







- (void)startInAppScreenSharingFromViewController:(UIViewController *)viewController callback:(void (^) (NSError *error))callback
{
if (![[RPScreenRecorder sharedRecorder] isAvailable]) {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-2 userInfo:@{@"SKYLINK" : @"Your screen recorder is not available, please restart the device"}]);
return;
}
[self clearLocalVideoView];
if (!USE_UNIFIED_PLAN) {
_sharingLms = [self.peerConnectionFactory mediaStreamWithStreamId:[NSString stringWithFormat:@"%@_sharing", [self myStreamId]]];
self.localMediaStream = _sharingLms;
}

dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
[self userDidFinishSetup:viewController callback:callback];
});
}









- (void)stopInAppScreenSharingWithCallback:(void (^) (NSError *error))callback
{
if (![[RPScreenRecorder sharedRecorder] isRecording]) {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-3 userInfo:@{@"SKYLINK" : @"You haven't started the sharing"}]);
return;
}

[self.handler broadcastFinishedWithCallback:callback];
[self clearLocalVideoView];
if (!USE_UNIFIED_PLAN) {
[_localVTrack addRenderer:self.screenVideoView];
self.screenVideoView.videoTrack = _localVTrack;
self.screenVideoView.audioTrack = self.localAudioTrack;
self.localMediaStream = lms;

for (NSString *remotePeerId in self.remotePeerIdPool) {
[self refreshConnection:remotePeerId];
}
}

if ([[self.localPeer.localSkylinkMediaMap allKeys] containsObject:_localScreenMediaId]) {
SKYLINKMedia *localScreenMedia = self.localPeer.localSkylinkMediaMap[_localScreenMediaId];
localScreenMedia.mediaType = SKYLINKMediaTypeVideoScreen;
localScreenMedia.mediaState = SKYLINKMediaStateStopped;
localScreenMedia.previousMediaState = SKYLINKMediaStateActive;
localScreenMedia.videoView = self.screenVideoView;
[self.localPeer.localSkylinkMediaMap setObject:localScreenMedia forKey:localScreenMedia.mediaID];
}
}












if (!USE_UNIFIED_PLAN) {
[_sharingLms addAudioTrack:self.localAudioTrack];
[_sharingLms addVideoTrack:localVideoTrack];
[self.screenVideoView renderFrame:nil];
[localVideoTrack addRenderer:self.screenVideoView];
self.screenVideoView.audioTrack = self.localAudioTrack;
self.screenVideoView.videoTrack = localVideoTrack;
for (NSString *remotePeerId in self.remotePeerIdPool) {
[self refreshConnection:remotePeerId];
}
} else {
if (![[self.localPeer.localSkylinkMediaMap allKeys] containsObject:_localScreenMediaId]) {
SKYLINKMedia *localScreenMedia = [[SKYLINKMedia alloc] initWithMediaTrack:localVideoTrack isVideo:YES createMediaID:YES];
localScreenMedia.mediaType = SKYLINKMediaTypeVideoScreen;
localScreenMedia.mediaState = SKYLINKMediaStateActive;
localScreenMedia.previousMediaState = SKYLINKMediaStateUnavailable;
localScreenMedia.videoView = self.screenVideoView;
[self.localPeer.localSkylinkMediaMap setObject:localScreenMedia forKey:localScreenMedia.mediaID];
_localScreenMediaId = localScreenMedia.mediaID;
} else {
SKYLINKMedia *localScreenMedia = self.localPeer.localSkylinkMediaMap[_localScreenMediaId];
localScreenMedia.mediaType = SKYLINKMediaTypeVideoScreen;
localScreenMedia.mediaState = SKYLINKMediaStateActive;
localScreenMedia.previousMediaState = SKYLINKMediaStateStopped;
localScreenMedia.videoView = self.screenVideoView;
[self.localPeer.localSkylinkMediaMap setObject:localScreenMedia forKey:localScreenMedia.mediaID];
}

RTCRtpSender *v1sender = [self.peerConnectionU addTrack:localVideoTrack streamIds:@[[self myStreamId]]];
[self.localVideoTracks addObject:localVideoTrack];

[self.screenVideoView renderFrame:nil];
[localVideoTrack addRenderer:self.screenVideoView];
self.screenVideoView.videoTrack = localVideoTrack;
self.screenVideoView.audioTrack = self.localAudioTrack;

for (NSString *remotePeerId in self.remotePeerIdPool) {
[self sendOfferForUnifiedPlanOf:remotePeerId];
}
_screenTrack = localVideoTrack;

SKYLINKPeerHolder *remotePeer = [self holderForPeerConnection:self.peerConnectionU];
SKYLINKMedia *localScreenMedia = [[SKYLINKMedia alloc] initWithMediaTrack:localVideoTrack isVideo:YES createMediaID:YES];
localScreenMedia.mediaState = SKYLINKMediaStateActive;
localScreenMedia.previousMediaState = SKYLINKMediaStateUnavailable;
localScreenMedia.videoView = self.screenVideoView;
localScreenMedia.rtpSender = v1sender;
[remotePeer.localSkylinkMediaMap setObject:localScreenMedia forKey:localScreenMedia.mediaID];
if (self.mediaDelegate && [self.mediaDelegate respondsToSelector:@selector(connection:didCreateLocalMedia:)]) {
[self.mediaDelegate connection:self didCreateLocalMedia:localScreenMedia];
}
}






- (void)clearLocalVideoView
{
[self.cameraVideoView.videoTrack removeRenderer:self.localVideoView];
self.localVideoView.videoTrack = nil;
[self.localVideoView renderFrame:nil];
}









/// stop capturing
- (void)stopLocalMediaWithMeidaID:(NSString *)mediaID callback:(void (^) (NSError *error))callback
{
if (!mediaID) {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-4 userInfo:@{NSLocalizedDescriptionKey : @"You must provide a mediaID"}]);
return;
}
if (![[self.localPeer.localSkylinkMediaMap allKeys] containsObject:mediaID]) {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-5 userInfo:@{NSLocalizedDescriptionKey : @"The mediaID you provided is not contained inside the map"}]);
return;
}
SKYLINKMedia *localMedia = self.localPeer.localSkylinkMediaMap[mediaID];
switch (localMedia.mediaType) {
case SKYLINKMediaTypeVideoScreen:
{
if (![[RPScreenRecorder sharedRecorder] isRecording]) {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-3 userInfo:@{NSLocalizedDescriptionKey : @"You haven't started the sharing"}]);
return;
}
[self.handler broadcastFinishedWithCallback:callback];

localMedia.mediaType = SKYLINKMediaTypeVideoScreen;
localMedia.mediaState = SKYLINKMediaStateUnavailable;
localMedia.previousMediaState = SKYLINKMediaStateActive;
localMedia.videoView = nil;

for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
if ([transceiver.sender.senderId isEqualToString:_v1senderId ? _v1senderId : WEBRTC_SCREEN_VIDEO]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[remotePeer.peerConnection removeTrack:transceiver.sender];
}
}
}

dispatch_async(dispatch_get_main_queue(), ^{
[self.screenVideoView.videoTrack removeRenderer:self.screenVideoView];
self.screenVideoView.videoTrack = nil;
[self.screenVideoView renderFrame:nil];
});

[self.localPeer.localSkylinkMediaMap removeObjectForKey:localMedia.mediaID];

// send message
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
[remotePeer.localSkylinkMediaMap removeObjectForKey:_localScreenMediaId];
// only need to send a new offer to the remote
[self sendOfferForUnifiedPlanOf:remotePeer.tid];
}

// trigger local delegate callback
dispatch_async(dispatch_get_main_queue(), ^{
if (self.mediaDelegate && [self.mediaDelegate respondsToSelector:@selector(connection:didChangeSkylinkMedia:peerId:)]) {
[self.mediaDelegate connection:self didChangeSkylinkMedia:localMedia peerId:self.localPeer.mid];
}
});
_localScreenMediaId = nil;
}
break;
case SKYLINKMediaTypeVideoCamera:
{
if (self->haveVideoSend && [self.cameraVideoView.videoTrack isEnabled] && _capturer) {
if ([_capturer.captureSession isRunning]) {
[_capturer.captureSession stopRunning];
SKILog(@"Local video stopped.");
localMedia.mediaType = SKYLINKMediaTypeVideoCamera;
localMedia.mediaState = SKYLINKMediaStateUnavailable;
localMedia.previousMediaState = SKYLINKMediaStateActive;
localMedia.videoView = nil;

dispatch_async(dispatch_get_main_queue(), ^{
[self.cameraVideoView.videoTrack removeRenderer:self.cameraVideoView];
self.cameraVideoView.videoTrack = nil;
[self.cameraVideoView renderFrame:nil];
});
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
/**
for (SKYLINKMedia *media in remotePeer.localSkylinkMediaMap.allValues) {
if ([transceiver.sender isEqual:media.rtpSender]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[self.peerConnectionU removeTrack:transceiver.sender];
}
}
*/
if ([transceiver.sender.senderId isEqualToString:SKYLINK_CAMERA_VIDEO]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[remotePeer.peerConnection removeTrack:transceiver.sender];
}
}
}

[self.localPeer.localSkylinkMediaMap removeObjectForKey:localMedia.mediaID];
// send message
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
[remotePeer.localSkylinkMediaMap removeObjectForKey:_localCameraMediaId];
// only need to send a new offer to the remote
[self sendOfferForUnifiedPlanOf:remotePeer.tid];
}

dispatch_async(dispatch_get_main_queue(), ^{
if (self.mediaDelegate && [self.mediaDelegate respondsToSelector:@selector(connection:didChangeSkylinkMedia:peerId:)]) {
[self.mediaDelegate connection:self didChangeSkylinkMedia:localMedia peerId:self.localPeer.mid];
}
});
} else {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-6 userInfo:@{NSLocalizedDescriptionKey : @"Your video had already been stopped."}]);
return;
}
}
_localCameraMediaId = nil;
_capturer = nil;
self.cameraDevice = nil;
}
break;
case SKYLINKMediaTypeAudio:
{
if (!self.client) return;
if (haveAudioSend) {
[self.localAudioTrack setIsEnabled:NO];
SKILog(@"Sending muteAudio = %@", [SKYLINKUtilities getBoolString:NO]);
[self.client sendGroupMessage:@{@"type": @"muteAudioEvent", @"mid": self.client.webResponse.sid, @"rid": self.client.webResponse.roomId, @"muted": @(YES)}];
localMedia.mediaType = SKYLINKMediaTypeAudio;
localMedia.mediaState = SKYLINKMediaStateUnavailable;
localMedia.previousMediaState = SKYLINKMediaStateActive;

// send message
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
if ([transceiver.sender.senderId isEqualToString:SKYLINK_AUDIO]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[remotePeer.peerConnection removeTrack:transceiver.sender];
}
}
}

[self.localPeer.localSkylinkMediaMap removeObjectForKey:localMedia.mediaID];
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
[remotePeer.localSkylinkMediaMap removeObjectForKey:_localAudioMediaId];
// only need to send a new offer to the remote
[self sendOfferForUnifiedPlanOf:remotePeer.tid];
}

dispatch_async(dispatch_get_main_queue(), ^{
if (self.mediaDelegate && [self.mediaDelegate respondsToSelector:@selector(connection:didChangeSkylinkMedia:peerId:)]) {
[self.mediaDelegate connection:self didChangeSkylinkMedia:localMedia peerId:self.localPeer.mid];
}
});
}
_localAudioMediaId = nil;
}
break;
case SKYLINKMediaTypeVideoCustom:
{
if (self->haveVideoSend && [self.cameraVideoView.videoTrack isEnabled]) {
if ([_capturer.captureSession isRunning]) {
[_capturer.captureSession stopRunning];
SKILog(@"Local video stopped.");
localMedia.mediaType = SKYLINKMediaTypeVideoCustom;
localMedia.mediaState = SKYLINKMediaStateUnavailable;
localMedia.previousMediaState = SKYLINKMediaStateActive;
localMedia.videoView = nil;

dispatch_async(dispatch_get_main_queue(), ^{
[self.cameraVideoView.videoTrack removeRenderer:self.cameraVideoView];
self.cameraVideoView.videoTrack = nil;
[self.cameraVideoView renderFrame:nil];
});

for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
/**
for (SKYLINKMedia *media in remotePeer.localSkylinkMediaMap.allValues) {
if ([transceiver.sender isEqual:media.rtpSender]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[self.peerConnectionU removeTrack:transceiver.sender];
}
}
*/
if ([transceiver.sender.senderId isEqualToString:SKYLINK_CAMERA_VIDEO]) {
localMedia.transceiverMid = transceiver.mid;
localMedia.rtpTransceiver = transceiver;
localMedia.rtpSender = transceiver.sender;
[remotePeer.peerConnection removeTrack:transceiver.sender];
}
}
}
[self.localPeer.localSkylinkMediaMap removeObjectForKey:localMedia.mediaID];
// send message
for (SKYLINKPeerHolder *remotePeer in self.peerHolderPool.allValues) {
[remotePeer.localSkylinkMediaMap removeObjectForKey:_localCameraMediaId];
// only need to send a new offer to the remote
[self sendOfferForUnifiedPlanOf:remotePeer.tid];
}

dispatch_async(dispatch_get_main_queue(), ^{
if (self.mediaDelegate && [self.mediaDelegate respondsToSelector:@selector(connection:didChangeSkylinkMedia:peerId:)]) {
[self.mediaDelegate connection:self didChangeSkylinkMedia:localMedia peerId:self.localPeer.mid];
}
});
} else {
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-6 userInfo:@{NSLocalizedDescriptionKey : @"Your video had already been stopped."}]);
return;
}
}
_localCameraMediaId = nil;
_capturer = nil;
self.cameraDevice = nil;
}
break;
case SKYLINKMediaTypeVideo:
{
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-8 userInfo:@{NSLocalizedDescriptionKey : @"This is read only, please don't send this in"}]);
return;
}
break;
default:
callback([NSError errorWithDomain:@"io.temasys.SKYLINK" code:-8 userInfo:@{NSLocalizedDescriptionKey : @"This value is not supported"}]);
break;
}
}






SKDLog(@"objects ---> %@", objects);
NSString *subType = [objects objectForKey:@"subType"];
NSString *mediaId = [objects objectForKey:@"mediaId"];
NSString *target = [objects objectForKey:@"target"];
if ([subType isEqualToString:@"mediaStateChanged"]) {
    if (target && ![target isEqualToString:self.client.webResponse.sid]) return;
    SKYLINKMediaType mediaType = (SKYLINKMediaType)[SKYLINKUtilities mediaTypeFromString: [objects objectForKey:@"mediaType"]];
    SKYLINKMediaState mediaState = (SKYLINKMediaState)[SKYLINKUtilities mediaTypeFromString: [objects objectForKey:@"mediaState"]];
    SKYLINKMediaState mediaPrevState = (SKYLINKMediaState)[SKYLINKUtilities mediaTypeFromString: [objects objectForKey:@"mediaPrevState"]];
    NSString *transceiverMid = [objects objectForKey:@"transceiverMid"];
    
    SKYLINKPeerHolder *remotePeer = self.peerHolderPool[mid];
    @synchronized (self.peerHolderPool) {
        if ([remotePeer.remoteSkylinkMediaMap.allKeys containsObject:mediaId]) {
            SKYLINKMedia *media = remotePeer.remoteSkylinkMediaMap[mediaId];
            [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
        } else {
            if (remotePeer.bufferSkylinkMediaMap.count > 0) { // there is/are already SkylinkMedia obejct(s) inside, so take it out and update it(here it, not them because one xxx message only indicates one track change), after updating it, send sig xxx message to remote peer
                for (NSString *key in remotePeer.bufferSkylinkMediaMap.allKeys) {
                    if ([key isEqualToString:transceiverMid]) {
                        SKYLINKMedia *media = remotePeer.bufferSkylinkMediaMap[transceiverMid];
                        [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
                        // if find it and updated it, then break
                        break;
                    }
                }
            } else { // no SkylinkMedia object inside, so create new, and put it into the buffer media map, key is the transceiverMid
                SKYLINKMedia *media = [[SKYLINKMedia alloc] initWithMediaID:mediaId transceiverMid:transceiverMid mediaType:mediaType mediaState:mediaState];
                media.mediaType = mediaType;
                media.mediaState = mediaState;
                media.previousMediaState = mediaPrevState;
                for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
                    if ([transceiver.mid isEqualToString:transceiverMid]) {
                        media.rtpTransceiver = transceiver;
                        media.rtpSender = transceiver.sender;
                    }
                }
                if(transceiverMid){
                    [remotePeer.bufferSkylinkMediaMap setObject:media forKey:transceiverMid];
                }
                [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
            }
        }
    }
}






in the else if ([value compare:@"mediaStateChangeEvent"] == NSOrderedSame)

@synchronized (self.peerHolderPool) {
    if ([remotePeer.remoteSkylinkMediaMap.allKeys containsObject:mediaId]) {
        SKYLINKMedia *media = remotePeer.remoteSkylinkMediaMap[mediaId];
        [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
    } else {
        if (remotePeer.bufferSkylinkMediaMap.count > 0) { // there is/are already SkylinkMedia obejct(s) inside, so take it out and update it(here it, not them because one xxx message only indicates one track change), after updating it, send sig xxx message to remote peer
            for (NSString *key in remotePeer.bufferSkylinkMediaMap.allKeys) {
                if ([key isEqualToString:transceiverMid]) {
                    SKYLINKMedia *media = remotePeer.bufferSkylinkMediaMap[transceiverMid];
                    [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
                    // if find it and updated it, then break
                    break;
                }
            }
        } else { // no SkylinkMedia object inside, so create new, and put it into the buffer media map, key is the transceiverMid
            SKYLINKMedia *media = [[SKYLINKMedia alloc] initWithMediaID:mediaId transceiverMid:transceiverMid mediaType:mediaType mediaState:mediaState];
            media.mediaType = mediaType;
            media.mediaState = mediaState;
            media.previousMediaState = mediaPrevState;
            for (RTCRtpTransceiver *transceiver in remotePeer.peerConnection.transceivers) {
                if ([transceiver.mid isEqualToString:transceiverMid]) {
                    media.rtpTransceiver = transceiver;
                    media.rtpSender = transceiver.sender;
                }
            }
            [remotePeer.bufferSkylinkMediaMap setObject:media forKey:transceiverMid];
            [self updateSkylinkMediaInSigMessageWith:media mediaType:mediaType mediaId:mediaId mediaState:mediaState mediaPrevState:mediaPrevState transceiverMid:transceiverMid remotePeer:remotePeer remotePeerId:mid];
        }
    }
}





- (NSArray<NSDictionary *> *)getMediaArrayFromSdp:(RTCSessionDescription *)sdp mediaMap:(NSMutableDictionary<NSString *, SKYLINKMedia *> *)mediaMap roomId:(NSString *)roomId mid:(NSString *)mid target:(NSString *)target
{
    NSMutableArray<NSDictionary *> *mediaArr = [NSMutableArray array];
    NSArray *strArr = [sdp.sdp componentsSeparatedByString:@"c=IN IP4 0.0.0.0"];
    NSDictionary *messageDict;
    for (NSString *str in strArr) {
        if ([str containsString:@"\na=msid:"]) {
            NSString *trachIdStr = [str subStringFrom:@"\na=msid:" to:@"\na=rtcp-mux"];
            NSString *transceiverMidStr = [str subStringFrom:@"\na=mid:" length:1];
            if ([trachIdStr containsString:SKYLINK_AUDIO]) {
                for (SKYLINKMedia *media in mediaMap.allValues) {
                    if (media.skylinkMediaType == SKYLINKMediaTypeAudio) {
                        if (transceiverMidStr) media.transceiverMid = transceiverMidStr;
                        messageDict = @{@"rid" : roomId, @"mid" : mid, @"target" : target, @"type" : @"mediaStateChangeEvent", @"mediaId" : media.mediaID, @"mediaType" : [SKYLINKUtilities mediaTypeStringFrom:media.mediaType], @"mediaState" : [SKYLINKUtilities mediaStateStringFrom:media.mediaState], @"mediaPrevState" : [SKYLINKUtilities mediaStateStringFrom:media.previousMediaState], @"transceiverMid" : media.transceiverMid, @"label" : media.label ? media.label : @""};
                        [mediaArr addObject:messageDict];
                    }
                }
            }
            if ([trachIdStr containsString:WEBRTC_SCREEN_VIDEO]) {
                for (SKYLINKMedia *media in mediaMap.allValues) {
                    if (media.skylinkMediaType == SKYLINKMediaTypeVideoScreen) {
                        if (transceiverMidStr) media.transceiverMid = transceiverMidStr;
                        messageDict = @{@"rid" : roomId, @"mid" : mid, @"target": target, @"type" : @"mediaStateChangeEvent", @"mediaId" : media.mediaID, @"mediaType" : [SKYLINKUtilities mediaTypeStringFrom:media.mediaType], @"mediaState" : [SKYLINKUtilities mediaStateStringFrom:media.mediaState], @"mediaPrevState" : [SKYLINKUtilities mediaStateStringFrom:media.previousMediaState], @"transceiverMid" : media.transceiverMid, @"label" : media.label ? media.label : @""};
                        [mediaArr addObject:messageDict];
                    }
                }
            }
            if ([trachIdStr containsString:SKYLINK_CAMERA_VIDEO]) {
                for (SKYLINKMedia *media in mediaMap.allValues) {
                    if (media.skylinkMediaType == SKYLINKMediaTypeVideoCamera) {
                        if (transceiverMidStr) media.transceiverMid = transceiverMidStr;
                        messageDict = @{@"rid" : roomId, @"mid" : mid, @"target": target, @"type" : @"mediaStateChangeEvent", @"mediaId" : media.mediaID, @"mediaType" : [SKYLINKUtilities mediaTypeStringFrom:media.mediaType], @"mediaState" : [SKYLINKUtilities mediaStateStringFrom:media.mediaState], @"mediaPrevState" : [SKYLINKUtilities mediaStateStringFrom:media.previousMediaState], @"transceiverMid" : media.transceiverMid, @"label" : media.label ? media.label : @""};
                        [mediaArr addObject:messageDict];
                        continue;
                    }
                }
            }
        }
    }
    return mediaArr;
}
